\documentclass{article}
 
\usepackage{listings}
\usepackage{url}
 
\title{ENGS 116 Project Proposal}
\author{Gabe Stocco and Cory Cornelius}

\begin{document}
\maketitle
\begin{abstract}
In November of 2007, the National Institute for Standards and Technology (NIST) announced the request for submission of candidate algorithms for the Secure Hash Algorithm 3 (SHA-3).
Because of recent attacks against the current standards, NIST ``decided that it is prudent to develop a new hash algorithm to augment and revise FIPS 180–2'' \cite{Sha3Request}.

As the second round of candidates were recently chosen in September, we decided to choose few of these second-round candidates--CubeHash \cite{CubeHash}, Skein \cite{Skein}, and ECHO \cite{ECHO}--and see if it is feasible to implement them in a GPU computing architecture.
In particular, we chose use to implement them in Open Computing Language (OpenCL), which provides a framework for executing ``kernels'' on a variety of devices (e.g., CPUs, GPUs, etc.).

% FIXME: Add summary of findings.

\end{abstract}
 
\section*{Introduction}
Hash functions are a critical tool in computer security.
A hash function allows for fingerprinting and verification of a piece of data by running a deterministic algorithm over a set of data with the property that if any slight changes are made to the data a very different hash will result.
 
Recently, a number of popular and standard hash algorithms have been successfully attacked.
The widely used MD5 hashing algorithm has been demonstrated to be quite insecure \cite{Nostradamus}.
It has been shown to be cryptographically weak because it is not collision resistant and vulnerable to a kind of preimage attack--that is, it is very easy to create two arbitrary meaningful documents with the same hash.
In such a situation applications as varied as secure document downloading (using hashes as verification that you've received the right file) to online banking (hashes are used to verify security certificates for websites) can be compromised.
In addition, there have been recent serious attacks against one of the current standard hash algorithm, the Secure Hash Algorithm 1 (SHA-1) \cite{Sha1Collisions}.
Because SHA-2 is structurally similar to SHA-1 cryptographers believe SHA-2 will fall just as SHA-1 has.
 
As a result of these developments the National Institute of Standards and Technology (NIST) is currently running a competition to choose a new secure hash algorithm (SHA-3) \cite{Sha3Request}.
NIST is running this competition similarly to how they ran the competition for the new Advanced Encryption Standard (AES).
In particular, while a proposed algorithm might be stronger than every other proposed algorithm, the algorithm is useless if it takes a long time to execute.
Thus there is a requirement, as there similarly was in the AES competition, for the authors of the algorithm to provide documentation on the computational efficiency of the algorithm.
NIST will analyze ``each submission's optimized implementations on a variety of platforms as specified in Section 6.B, and for a variety of input message lengths.'' \cite{Sha3Request}.
Since computational efficiency will be an important part of the decision in choosing SHA-3 some authors of proposed algorithms have taken great care to design their algorithms in such a way to be exploit parallelism where ever possible.


\section*{Approach}
Because we are not skilled cryptographers and others are already analyzing these algorithms \cite{Sha3Zoo}, we will instead explore the runtime speed of a subset of the round 2 SHA-3 candidates.
We plan to evaluate the computational efficiency of the following SHA-3 candidates: Skein, CubeHash and Echo.
We choose Skein and CubeHash primarily based on the popularity of the authors in the cryptographic community, and we choose Echo because it is based upon AES.
While the each of these algorithms already have general purpose implementations we plan to implement them for execution on a GPU using the OpenCL and/or CUDA frameworks.
There is currently a wealth of information for FPGA and ASIC implementations of these algorithms, however we are unaware of OpenCL/CUDA implementations of any of the SHA-3 candidates \cite{Sha3Hardware}.
Our hypothesis is that some of these algorithms will benefit from parallel execution while others may not.
Thus, we will compare out runtime results on the GPU with runtime results on a CPU.
Our reference machine will be a Mac Pro with an ATI Radeon HD 4870 512MB. 
We also needed to use a NVIDIA 8800 GT 512MB because of incompatibilities (discussed later) between some hash functions and the ATI card.  
Our development machines were MacBook Pros with an NVIDIA 9400M 256MB and a NVIDIA 8600M GT 128MB
 
 
\section*{Algorithms}
We chose to implement SHA1 in OpenCL as a baseline to see how well the NIST competitors have been able to include parallelism in their designs.  Additionally, we implemented the CubeHash, ECHO, and Skein algorithms.

\subsection*{CubeHash}

CubeHash is perhaps the simplest SHA-3 candidate and, as such, as garnered significant attention.
CubeHash can be parameterized on the number of rounds $r$, the number of bytes per block $b$, and the number of output bits $h$.
For our tests, we chose $r=8$, $b=1$, and $h=512$ primarily because these were the recommended parameters specified by the author \cite{CubeHash-spec}.

\subsection*{ECHO}
ECHO is based largely on the AES block cipher chosen by NIST to replace the defunct Data Encryption Standard as an official federal government standard in the United States.
ECHO provides a number of advantages over other hash functions in the competition because is built upon the AES block cipher.
In particular, Intel chips starting with the current Nehalem core will have built in AES hardware support - allowing for three times faster operation than previous general purpose CPU chips.\cite{Westmere}
In addition to receiving performance enhancements from any AES optimizations built into hardware, testing ECHO on a GPU should also give some indication of how effective running AES as a GPGPU program would be.
Preliminary results from researchers have demonstrated up to a 2\cite{Harrison}-20x\cite{Manavski}  increase in encryption rate throughput by using the GPU as a encryption co-processor.
However, there is good reason to doubt the 20x figure as it appears that it was achieved through a naive implementation of AES using Electronic Code Book (ECB) mode.
Unlike more secure encryption modes, ECB mode encrypts data in finite sized chunks allowing for easy data parallelization.  
However, ECB mode is largely insecure for many use cases.\cite{CodeBook}\\

ECHO runs 8 rounds, each round consisting of 2 AES rounds.  Additionally, it uses a ShiftRows similar to AES but on 128 bit words, and AES MixColumns on 4-tuples. The only parameter to specify is the hashlength - we chose a default hashlength of 512 bits for our tests, but also ran a test with varied hash length to compare against CubeHash.

\subsection*{Skein}
Skein was developed by Niels Ferguson and Bruce Schneier - a big name in the cryptography and security community.
Skein is based on the Threefish block cipher and supports internal block sizes of 256, 512 or 1024 bits.
Skein allows for arbitrary digest size, was designed for 64 bit processors and speed was a primary consideration of the design.
According to the authors, Skein can run at 6.1 clock cycles/byte on a Core 2 Duo in 64 bit mode\cite{SkeinSpeed} compared with the estimated 200 clock cycles/byte for the CubeHash hash function, this means that Skein can run faster than even SHA1 or SHA2 while providing much greater security.
Skein also has a number of optional features or alternate implementation modes which can allow for use as a ``a PRNG, a stream cipher, a key derivation function, authentication without the overhead of HMAC''\cite{SkeinSpeed}.
It also has an optional hash-tree mode for increasing parallel execution speed. 


\section*{Implementation}

For each hash function we established a standard model for implementation: each hash function has internal Init, Update and Final function.
Each of these functions was converted to an OpenCL kernel we wrote a wrapper in Python using the PyOpenCL library to implement our evaluation methodology.  Specific implementation details and roadblocks encountered follow.

\subsection*{CubeHash}

\subsection*{Echo}

As part of the submissions materials to the NIST competition the ECHO team submitted a 32 bit optimized version, a 64-bit optimized version and a reference implementation.  
We chose to base our OpenCL implementation on the reference implementation, hoping that it would be the most likely to work with little modification.
As it turned out the Echo function required a good deal of work to get to work.
We began the debugging process by flattening all the functions into the kernel to avoid any issues with pointer passing causing data to not be written back to the global buffers.
After having done this however, we still did not have a functional hash function - at least it was functional on the cpu but not the GPU.  
We at first did not have any idea how to resolve this issue - since it is very difficult to debug code that cannot contain any print statements and cannot write out to a file. 
Eventually, we began debugging by setting the return value of the hash to the memory that we wanted to look at, and began comparing the results from code that ran on teh CPU to the same code running on the GPU.
By doing this we found a number of small errors in the code.

Finally, the largest problem turned out to the be the accessible scope of the S-box.
Since the S-box was declared in the same file as the kernel we had assumed that it would be in the scope of the kernel and it would be stored in the local memory of the graphics card.
As it turned out by declaring the S-box outside of the actual kernel it was not instantiating the S-box in the local memory of the graphics card and instead when we tried to access the values of the S-box we only got 0's back.
It was particularly difficult to spot the error because the program behaved differently on the CPU and GPU - on the CPU it accessed the S-boxes as normal, but the GPU was unable to do the same until they were moved into the kernel.
\subsection*{Skein}


\section*{Evaluation}

\subsection*{Test Machine Specifications}
\begin{verbatim}
Apple Mac Pro w/ 2 x 2.26 Xeon `Nehalem' core
12 GB RAM
Primary: NVIDIA GeForce 8800 512MB
Secondary: ATI Radeon 4870 512MB
\end{verbatim}

\subsection*{Methodology}
Each algorithm was run 5 times on both the CPU and the NVIDIA GPU using data ranging in size from 1 byte ($2^0$) to 1,048,576 bytes ($2^{20}$) by powers of 2.
By testing values throughout this range we are able to see both how much base overhead each function has, but also how well they will perform when overhead becomes irrelevant and they achieve a near constant processing rate.
Skein was the only algorithm which ran properly on the ATI card so was tested by itself on that configuration.

Additionally, CubeHash and Echo were the only algorithms which allowed arbitrary hash bit length, and were tested for speed vs. hash bit length for a fixed data size of 32 bytes.
32 bytes was chosen because CubeHash and Echo performed nearly identically for a 32 byte data input using a 512 bit hash in the original tests.

\subsection*{CubeHash}
CubeHash is really slow.
Really really slow.
The author of CubeHash acknowledged this publicly and suggested some non standard settings which would make it run somewhat faster.  
In particular: the default settings are to run 8 rounds of CubeHash for every single byte in the input data, for our test suite: 64 byte increments to 8192 bytes 10 times, this would result in 41943040 rounds being performed.
We attempted to run the full suite on the original CubeHash on the ATI GPU and it did not complete in an hour.

The author's recommended solution is to instead use 16 rounds for each 32 bytes.
We also changed to using 128 byte increments and only 5 run averages bringing the number of rounds performed to 655360.
Using the reduced computation version of CubeHash the GPU completed computation in only 137 seconds - it would have taken about 2.5 hours to complete the full computations on the full CubeHash algorithm.



\subsection*{Echo}
ECHO was possibly the most troublesome of the algorithms to implement - never successfully running on the ATI card.  
When we attempted to run ECHO on ATI card it would lock up the entire system requiring a hard shutdown. 
However, when run with the NVIDIA 8800 it would run without issue.
ECHO proved particularly difficult to code in OpenCL.

Echo ran at a maximum of 1675.7 ns/byte on the CPU and 354162.5 ns/byte on the GPU.
This translates to 741.5 clocks/byte on the CPU (at 2.26 Ghz) and 590,270 clocks/byte on the GPU (at 600 Mhz).

\subsection*{Skein}
Skein was by far the fastest algorithm tested.
It was the only algorithm able to run the full 1,048,576 byte data set on the GPU - though it was only able to do this on the Radeon and not the GeForce card which the other algorithms ran better on.

Skein ran at 7.8 clocks/byte (17.67 ns/byte) on the CPU, 27.8\% more than the claimed 6.1 clocks/byte and 6,626.1 clocks/byte (3975.65 ns/byte) on the GPU.

\section*{Conclusions}

We can conclude from this study that if only speed is taken into account, no matter your hardware configuration you should choose the Skein algorithm.
About OpenCL we can conclude that it is not yet ready for production use.
Even across two video cards specifically supported by Apple's implementation of OpenCL these hash functions performed in drastically different ways.
Additionally, a kernel run on a CPU can often perform in drastically different ways than the same kernel run on a GPU.



\begin{thebibliography}{9}
  \bibitem{Sha3Request} ``Announcing Request for Candidate Algorithm Nominations for a New Cryptographic Hash Algorithm (SHAÐ3) Family.'' Federal Registrar, Vol. 72, No. 212 (November 2007), pp. 62212-62220. Available at \url{http://csrc.nist.gov/groups/ST/hash/documents/FR_Notice_Nov07.pdf}.
  \bibitem{Nostradamus} Marc Stevens, Arjen K. Lenstra, Benne de Weger. ``Predicting the winner of the 2008 US Presidential Elections using a Sony PlayStation 3.'' November 30, 2007. Available at \url{http://www.win.tue.nl/hashclash/Nostradamus/}
  \bibitem{Sha1Collisions} Xaoyun Wang, Yiqun Lisa Yin, Hongbo Yu. ``Finding Collisions in the Full SHA-1.'' Lecture Notes in Computer Science, Vol. 3621 (November 2005), pp. 17-36
  \bibitem{Sha3Zoo} ``The SHA-3 Zoo.'' Available at \url{http://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo}
  \bibitem{Sha3Hardware} ``SHA-3 Hardware Implementations.'' Available at \url{http://ehash.iaik.tugraz.at/wiki/SHA-3_Hardware_Implementations}
  \bibitem{Westmere} ``Intel Nehalem (microarchitecture).'' Available at \url{http://en.wikipedia.org/wiki/Intel_Westmere}
  \bibitem{CubeHash} ``CubeHash: a simple hash function.'' Available at \url{http://cubehash.cr.yp.to/}
  \bibitem{CubeHash-spec} Bernstein, Daniel J. ``CubeHash specification (2.B.1).'' Available at \url{http://cubehash.cr.yp.to/submission/spec.pdf}.
  \bibitem{Skein} ``The Skein Hash Function Family.'' Available at \url{http://www.skein-hash.info/} and \url{http://www.schneier.com/skein.html}
  \bibitem{ECHO} ``ECHO Hash Function.'' Available at \url{http://crypto.rd.francetelecom.com/echo/}.
  \bibitem{Harrison} Owen Harrison and John Waldron. ``AES Encryption Implementation and Analysis on Commodity Graphics Processing Units.'' Available at \url{https://www.cs.tcd.ie/~harrisoo/publications/AES_On_GPU.pdf}.
  \bibitem{CodeBook} ``Block cipher modes of operation'' Available at \url{http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29}.
  \bibitem{Manavski} ``CUDA COMPATIBLE GPU AS AN EFFICIENT HARDWARE ACCELERATOR FOR AES CRYPTOGRAPHY.'' Available at \url{http://www.manavski.com/downloads/PID505889.pdf}
  \bibitem{SkeinSpeed} ``The Skein Hash Function Family.'' Available at \url{http://www.schneier.com/skein.html}
\end{thebibliography}

\end{document}